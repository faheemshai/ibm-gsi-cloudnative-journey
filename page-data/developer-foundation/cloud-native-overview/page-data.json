{"componentChunkName":"component---src-pages-developer-foundation-cloud-native-overview-index-mdx","path":"/developer-foundation/cloud-native-overview/","result":{"pageContext":{"frontmatter":{"title":"What is Cloud-Native?","description":"Cloud-native overview."},"relativePagePath":"/developer-foundation/cloud-native-overview/index.mdx","titleType":"page","MdxNode":{"id":"17017ce3-fb6b-54b7-95fb-479b418cee96","children":[],"parent":"b0d952d7-6117-5d79-8411-a49e42d5841a","internal":{"content":"---\ntitle: What is Cloud-Native?\ndescription: Cloud-native overview.\n---\n\n## Introduction\n\nCloud is everywhere. Today, many companies want to migrate their\napplications to the cloud. For this to be done, the\napplications must be re-architected to fully use the cloud advantages.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fp9_ubiKqFU\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## What is Cloud-Native?\n\nCloud-native is about how we build and run applications taking full\nadvantage of cloud computing rather than worrying about where we deploy\nit:\n\n-   A cloud-native application consists of discrete and reusable components\n    known as microservices that are designed to integrate into any cloud\n    environment.\n\n-   These microservices act as building blocks and are often packaged in\n    containers.\n\n-   Microservices work together as a whole to comprise an application,\n    yet each can be independently scaled, continuously improved, and\n    quickly iterated through automation and orchestration processes.\n\n-   The flexibility of each microservice adds to the agility and\n    continuous improvement of cloud-native applications.\n\n**CNCF Cloud-Native Definition**\n\nCloud-native technologies empower organizations to build and run\nscalable applications in modern, dynamic environments such as public,\nprivate, and hybrid clouds. Containers, service meshes, microservices,\nimmutable infrastructure, and declarative APIs exemplify this approach.\n\nThese techniques enable loosely coupled systems that are resilient,\nmanageable, and observable. Combined with robust automation, they allow\nengineers to make high-impact changes frequently and predictably with\nminimal toil.\n\nThe Cloud-Native Computing Foundation seeks to drive adoption of this\nparadigm by fostering and sustaining an ecosystem of open source,\nvendor-neutral projects. We democratize state-of-the-art patterns to\nmake these innovations accessible for everyone.\n\n## Why Cloud-Native?\n\nCloud-native applications are different from the traditional\napplications that run in your data centers. Traditional applications\nare not built with cloud\ncompatibility in mind. They may have strong ties with the internal\nsystems and they cannot take advantage of all the benefits of the\ncloud.\n\nWe need a new architecture for our applications to utilize the\nbenefits of the cloud. The applications' design needs to keep\nthe cloud in mind and take advantage of cloud services like storage,\nqueuing, caching, etc.\n\n-   Speed, safety, and scalability come with cloud-native applications.\n\n-   Helps to quickly deliver the advancements.\n\n-   Allows loose ties into the corporate IT where it can\n    destabilize legacy architectures.\n\n-   Allows continuous deployment of applications with zero downtime.\n\n-   Infrastructure is less predictable.\n\n-   Service instances are all disposable.\n\n-   Deployments are immutable.\n\n-   To meet the expectations of today’s world customers, these\n    systems are architected for elastic scalability.\n\n## Cloud-native concepts\n\nSome of the important characteristics of cloud-native applications are\nas follows.\n\n-   Disposable infrastructure.\n\n-   Isolation.\n\n-   Scalability.\n\n-   Disposable architecture.\n\n-   Value-added cloud services.\n\n-   Polyglot cloud.\n\n-   Self-sufficient, full-stack teams.\n\n-   Cultural Change.\n\n**Disposable Infrastructure**\n\nWhile creating applications on the cloud, you need several cloud resources\nas part of it. We often hear how easy it is to create all these\nresources. But did you ever think about how easy is to dispose of them? It's\nnot easy and that's why you don’t hear much about it.\n\nIn traditional or legacy applications, we have all these resources\nresiding on machines. If these go down, we need to redo them again and\nmost of this is handled by the operations team manually. So, when we are\ncreating applications on the cloud, we bring those resources like load\nbalancers, databases, and gateways as well along with\nmachine images and containers.\n\nWhile creating these applications, you should always keep in mind that\nif you are creating a resource on demand, you should also be able to\ndestroy it when not required. Without this, we cannot achieve the\nfactors speed, safety, and scalability. If you want this to happen, we\nneed automation.\n\nAutomation allows you to:\n\n-   Deliver new features at any time.\n\n-   Deliver patches faster.\n\n-   Improve system quality.\n\n-   Facilitate team scale and efficiency.\n\nNow you should know what we are talking about. Disposable infrastructure is\nnothing but `Infrastructure as Code`.\n\n***Infrastructure as Code***\n\nHere, you develop the code for automation exactly as same as you do\nfor the rest of the application using agile methodologies.\n\n-   Automation code is driven by a story.\n\n-   Versioned in the same repository as the rest of the code.\n\n-   Continuously tested as part of the CI/CD pipeline.\n\n-   Test environments are created and destroyed along with test runs.\n\nThus, disposable infrastructure lays the groundwork for scalability and\nelasticity.\n\n**Isolation**\n\nIn traditional or legacy monolithic applications when you fix a bug or an \nerror, the entire application needs to be redeployed.\nThis can cause side effects that you can never predict. Changes\nmay break any components in the application as they are all inter\nrelated.\n\nIn cloud-native applications, to avoid the above scenario, the system is\ndecomposed into bounded isolated components. Each service will be\ndefined as one component independent of others. This way, when there is a\nbug or error in the application, you can just fix the specific\ncomponent avoiding any side effects as the\ncomponents are all unrelated pieces of code.\n\nThus, cloud-native systems are resilient to human-made errors. To\nachieve this we need isolation to avoid a problem in a single\ncomponent affecting the entire system. This also helps you to introduce\nchanges the application quickly and with confidence.\n\n**Scalability**\n\nSimply deploying your application to the cloud does not make it\ncloud-native. To be cloud-native it needs to use the full benefits\nof the cloud. One key feature is scalability.\n\nIn today’s world, once your business starts growing, the number of users\nkeeps increasing and they may be from different locations. Your\napplication should be able to support a large number of devices while \nmaintaining its responsiveness using an efficient and cost-effective way.\n\nTo achieve this, a cloud-native application runs in multiple runtimes\nspread across multiple hosts. The applications should be designed and\narchitected so it supports multiple regions and active-active\ndeployments. This helps you to increase the availability and avoids\nsingle-point failures.\n\n**Disposable architecture**\n\nLeveraging the disposable infrastructure and scaling isolated components\nis important for cloud-native applications. Disposable architecture is\nbased on this and it takes disposability and replacement concepts to\nthe next level.\n\nMost of us think in a monolithic way because we are used to traditional\nor legacy applications. This may lead us to make decisions in a\nmonolithic way rather than in a cloud-native way. With monolithic thinking,\nwe tend to be safe and don’t do a lot of experimentation. But disposable\narchitecture is exactly the opposite. In this\napproach, we develop small pieces of the component and keep\nexperimenting with it to find an optimal solution.\n\nWhen there is a breakthrough in the application, you can’t simply make\ndecisions based on the available information which may be incomplete or\ninaccurate. So, with disposable architecture, you start with small\nincrements, and invest time to find the optimal solution. Sometimes,\nthere may be a need to completely replace the component, but that\ninitial work was just the cost of getting the information that caused\nthe breakthrough. This helps you to minimize waste allowing you to use\nyour resources on controlled experiments efficiently and get good value\nout of it in the end.\n\n**Value-added cloud services**\n\nWhen you are defining an application, there are many things you need to\ncare about. Every service will be associated with many things like\ndatabases, storage, redundancy, monitoring, etc. For your application,\nalong with your components, you also need to scale the data. You can\nreduce the operational risk and also get all such things at greater\nvelocity by leveraging the value-added services that are available on\nthe cloud. Sometimes, you may need third party services if they are not\navailable on your cloud. You can externally hook them up with your\napplication as needed.\n\nBy using the value-added services provided by your cloud provider, you\nwill get to know all the available options on your cloud and you can\nalso learn about all the new services. This will help you to take good\nlong-termed decisions. You can use a different service if you find\nit more suitable for your component and hook that up with your\napplication based on the requirements.\n\n**Polyglot cloud**\n\nMost of you are familiar with polyglot programming. For your\napplication, based on the component, you can choose the programming\nlanguages that best suits it. You need not stick to a single programming\nlanguage for the entire application. If you consider polyglot\npersistence, you can choose the storage mechanism that better suits\nin a component by component basis. It allows a better global scale.\n\nSimilarly, the next thing will be a polyglot cloud. Like above, here you\nchoose a cloud provider that better suits your application in a component\nby component\nbasis. For the majority of your components, you may have to go to your cloud\nprovider. But, this does not stop you from choosing a different one if\nit suits well for any of your application components. So, you can run\ndifferent components of your cloud-native system on different cloud\nproviders based on your requirements.\n\n**Self-sufficient, full-stack teams**\n\nIn a traditional setup, many organizations have teams based on skill sets\nlike backend, user interface, database, operations, etc. Such a\nstructure will not allow you to build cloud-native systems.\n\nIn cloud-native systems, the system is composed of bounded isolated\ncomponents that have their own resources. Each one of such components must\nbe owned by a self-sufficient, full-stack team entirely\nresponsible for all the resources that belong to that particular\ncomponent. In this setup, this team tends to focus on quality upfront as\nthey are the ones who deploy it and they will be taking care of it if\nthe component is broken. It is more like you build it and then you run\nit. So, the team can continuously deliver advancements to the components\nat their own pace. Also, they are completely responsible for delivering\nthese safely.\n\n**Cultural Change**\n\nCloud-native is a different way of thinking. We need to first make up our\nminds, not just the systems, to utilize the full benefits of the cloud.\nCompared to the traditional systems, there will be lots of things we do\ndifferently in cloud-native systems.\n\nTo make that happen, cultural change is really important. To change the\nthinking at a high level, we just to first prove that the low-level\npractices can truly deliver and encourage lean thinking. With these\npractices, you can conduct experimentation. Based on the feedback from\nbusiness, you can quickly and safely deliver your applications that can\nscale.\n\n## Cloud-native Roadmap\n\nYou can define your cloud-native roadmap in many ways. You can get\nthere by choosing different paths. Let us see the trail map defined by\nCNCF.\n\nCNCF defined the Cloud-Native Trail Map providing an overview for\nenterprises starting their cloud-native journey as follows.\n\nThis cloud map gives us various steps that an engineering team may use\nwhile considering the cloud-native technologies and exploring them. The\nmost common ones among them are containerization, CI/CD, and\norchestration. The next crucial pieces will be observability & analysis and\nservice mesh. And later comes the rest of them like networking,\ndistributed database, messaging, container runtime, and software\ndistribution based on your requirements.\n\n![CNCF\\_TrailMap\\_latest.png](./images/CNCF_TrailMap_latest.png)\n\n-   You cannot build cloud-native applications without containerization.\n    This helps your application to run in any computing\n    environment. Basically, all your code and dependencies are packaged\n    up together  into a single unit here. Among the different container\n    platforms available, Docker is the preferred one.\n\n-   It's convenient to set up a CI/CD pipeline to bring all the changes\n    in the code to the container automatically. There are many\n    tools available for this like Jenkins, Travis, etc.\n\n-   We need container orchestration to manage its lifecycles. \n    Kubernetes is a popular solution.\n\n-   Monitoring and observability play a very important role so it's\n    recommended to use techniques like logging, tracing, metrics\n    etc.\n\n-   To enable more complex operational requirements, you can use a\n    service mesh. It helps you out with several things like service\n    discovery, health, routing, A/B testing, etc. Istio is a popular tool.\n\n-   Networking plays a crucial role. You should define flexible\n    networking layers based on your requirements. For this, you can use\n    Calico, Weave Net, etc.\n\n-   Sometimes, you may need distributed databases. These are required\n    if you need more scalability and resiliency.\n\n-   Messaging may be required sometimes too. You can use queues like\n    Kafka, RabbitMQ, etc.\n\n-   Container registry helps you to store all your containers. You can\n    also enable image scanning and signing if required.\n\n-   As a part of your application, sometimes you may need a secure\n    software distribution.\n\nAlso, if you want to see the cloud-native landscape, check it out\n[here](https://landscape.cncf.io/images/landscape.png).\n\n## Summary\n\nIn this section, we covered the fundamentals of cloud-native systems. Now \nyou should know what cloud-native is, why we need it, and how important it is.\nCloud-native is not just deploying your application on the cloud, it's\nalso about taking full advantage of the cloud. Also, with the cloud-native\nroadmap, you will get an idea about how to design and architect your\ncloud-native system. You can also get an overview of the different tools,\nframeworks, platforms, etc. with the cloud-native landscape.\n\nYou can check\n[Cloud Native Applications](https://www.ibm.com/cloud/learn/cloud-native)\nif want to learn more.\n\n## References\n\n-   [Cloud Native Applications](https://www.ibm.com/cloud/learn/cloud-native)\n\n-   [John Gilbert, (2018). Cloud-Native Development Patterns and Best\n    Practices. Publisher: Packt\n    Publishing](https://learning.oreilly.com/library/view/cloud-native-development/9781788473927/)\n\n-   [CNCF landscape](https://github.com/cncf/landscape)\n\n-   [CNCF Definition](https://github.com/cncf/toc/blob/master/DEFINITION.md)\n","type":"Mdx","contentDigest":"7bfbe49cd3b143cd3bb1610b6f43696f","owner":"gatsby-plugin-mdx","counter":987},"frontmatter":{"title":"What is Cloud-Native?","description":"Cloud-native overview."},"exports":{},"rawBody":"---\ntitle: What is Cloud-Native?\ndescription: Cloud-native overview.\n---\n\n## Introduction\n\nCloud is everywhere. Today, many companies want to migrate their\napplications to the cloud. For this to be done, the\napplications must be re-architected to fully use the cloud advantages.\n\n<iframe width=\"560\" height=\"315\" src=\"https://www.youtube.com/embed/fp9_ubiKqFU\" frameborder=\"0\" allow=\"accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\" allowfullscreen></iframe>\n\n## What is Cloud-Native?\n\nCloud-native is about how we build and run applications taking full\nadvantage of cloud computing rather than worrying about where we deploy\nit:\n\n-   A cloud-native application consists of discrete and reusable components\n    known as microservices that are designed to integrate into any cloud\n    environment.\n\n-   These microservices act as building blocks and are often packaged in\n    containers.\n\n-   Microservices work together as a whole to comprise an application,\n    yet each can be independently scaled, continuously improved, and\n    quickly iterated through automation and orchestration processes.\n\n-   The flexibility of each microservice adds to the agility and\n    continuous improvement of cloud-native applications.\n\n**CNCF Cloud-Native Definition**\n\nCloud-native technologies empower organizations to build and run\nscalable applications in modern, dynamic environments such as public,\nprivate, and hybrid clouds. Containers, service meshes, microservices,\nimmutable infrastructure, and declarative APIs exemplify this approach.\n\nThese techniques enable loosely coupled systems that are resilient,\nmanageable, and observable. Combined with robust automation, they allow\nengineers to make high-impact changes frequently and predictably with\nminimal toil.\n\nThe Cloud-Native Computing Foundation seeks to drive adoption of this\nparadigm by fostering and sustaining an ecosystem of open source,\nvendor-neutral projects. We democratize state-of-the-art patterns to\nmake these innovations accessible for everyone.\n\n## Why Cloud-Native?\n\nCloud-native applications are different from the traditional\napplications that run in your data centers. Traditional applications\nare not built with cloud\ncompatibility in mind. They may have strong ties with the internal\nsystems and they cannot take advantage of all the benefits of the\ncloud.\n\nWe need a new architecture for our applications to utilize the\nbenefits of the cloud. The applications' design needs to keep\nthe cloud in mind and take advantage of cloud services like storage,\nqueuing, caching, etc.\n\n-   Speed, safety, and scalability come with cloud-native applications.\n\n-   Helps to quickly deliver the advancements.\n\n-   Allows loose ties into the corporate IT where it can\n    destabilize legacy architectures.\n\n-   Allows continuous deployment of applications with zero downtime.\n\n-   Infrastructure is less predictable.\n\n-   Service instances are all disposable.\n\n-   Deployments are immutable.\n\n-   To meet the expectations of today’s world customers, these\n    systems are architected for elastic scalability.\n\n## Cloud-native concepts\n\nSome of the important characteristics of cloud-native applications are\nas follows.\n\n-   Disposable infrastructure.\n\n-   Isolation.\n\n-   Scalability.\n\n-   Disposable architecture.\n\n-   Value-added cloud services.\n\n-   Polyglot cloud.\n\n-   Self-sufficient, full-stack teams.\n\n-   Cultural Change.\n\n**Disposable Infrastructure**\n\nWhile creating applications on the cloud, you need several cloud resources\nas part of it. We often hear how easy it is to create all these\nresources. But did you ever think about how easy is to dispose of them? It's\nnot easy and that's why you don’t hear much about it.\n\nIn traditional or legacy applications, we have all these resources\nresiding on machines. If these go down, we need to redo them again and\nmost of this is handled by the operations team manually. So, when we are\ncreating applications on the cloud, we bring those resources like load\nbalancers, databases, and gateways as well along with\nmachine images and containers.\n\nWhile creating these applications, you should always keep in mind that\nif you are creating a resource on demand, you should also be able to\ndestroy it when not required. Without this, we cannot achieve the\nfactors speed, safety, and scalability. If you want this to happen, we\nneed automation.\n\nAutomation allows you to:\n\n-   Deliver new features at any time.\n\n-   Deliver patches faster.\n\n-   Improve system quality.\n\n-   Facilitate team scale and efficiency.\n\nNow you should know what we are talking about. Disposable infrastructure is\nnothing but `Infrastructure as Code`.\n\n***Infrastructure as Code***\n\nHere, you develop the code for automation exactly as same as you do\nfor the rest of the application using agile methodologies.\n\n-   Automation code is driven by a story.\n\n-   Versioned in the same repository as the rest of the code.\n\n-   Continuously tested as part of the CI/CD pipeline.\n\n-   Test environments are created and destroyed along with test runs.\n\nThus, disposable infrastructure lays the groundwork for scalability and\nelasticity.\n\n**Isolation**\n\nIn traditional or legacy monolithic applications when you fix a bug or an \nerror, the entire application needs to be redeployed.\nThis can cause side effects that you can never predict. Changes\nmay break any components in the application as they are all inter\nrelated.\n\nIn cloud-native applications, to avoid the above scenario, the system is\ndecomposed into bounded isolated components. Each service will be\ndefined as one component independent of others. This way, when there is a\nbug or error in the application, you can just fix the specific\ncomponent avoiding any side effects as the\ncomponents are all unrelated pieces of code.\n\nThus, cloud-native systems are resilient to human-made errors. To\nachieve this we need isolation to avoid a problem in a single\ncomponent affecting the entire system. This also helps you to introduce\nchanges the application quickly and with confidence.\n\n**Scalability**\n\nSimply deploying your application to the cloud does not make it\ncloud-native. To be cloud-native it needs to use the full benefits\nof the cloud. One key feature is scalability.\n\nIn today’s world, once your business starts growing, the number of users\nkeeps increasing and they may be from different locations. Your\napplication should be able to support a large number of devices while \nmaintaining its responsiveness using an efficient and cost-effective way.\n\nTo achieve this, a cloud-native application runs in multiple runtimes\nspread across multiple hosts. The applications should be designed and\narchitected so it supports multiple regions and active-active\ndeployments. This helps you to increase the availability and avoids\nsingle-point failures.\n\n**Disposable architecture**\n\nLeveraging the disposable infrastructure and scaling isolated components\nis important for cloud-native applications. Disposable architecture is\nbased on this and it takes disposability and replacement concepts to\nthe next level.\n\nMost of us think in a monolithic way because we are used to traditional\nor legacy applications. This may lead us to make decisions in a\nmonolithic way rather than in a cloud-native way. With monolithic thinking,\nwe tend to be safe and don’t do a lot of experimentation. But disposable\narchitecture is exactly the opposite. In this\napproach, we develop small pieces of the component and keep\nexperimenting with it to find an optimal solution.\n\nWhen there is a breakthrough in the application, you can’t simply make\ndecisions based on the available information which may be incomplete or\ninaccurate. So, with disposable architecture, you start with small\nincrements, and invest time to find the optimal solution. Sometimes,\nthere may be a need to completely replace the component, but that\ninitial work was just the cost of getting the information that caused\nthe breakthrough. This helps you to minimize waste allowing you to use\nyour resources on controlled experiments efficiently and get good value\nout of it in the end.\n\n**Value-added cloud services**\n\nWhen you are defining an application, there are many things you need to\ncare about. Every service will be associated with many things like\ndatabases, storage, redundancy, monitoring, etc. For your application,\nalong with your components, you also need to scale the data. You can\nreduce the operational risk and also get all such things at greater\nvelocity by leveraging the value-added services that are available on\nthe cloud. Sometimes, you may need third party services if they are not\navailable on your cloud. You can externally hook them up with your\napplication as needed.\n\nBy using the value-added services provided by your cloud provider, you\nwill get to know all the available options on your cloud and you can\nalso learn about all the new services. This will help you to take good\nlong-termed decisions. You can use a different service if you find\nit more suitable for your component and hook that up with your\napplication based on the requirements.\n\n**Polyglot cloud**\n\nMost of you are familiar with polyglot programming. For your\napplication, based on the component, you can choose the programming\nlanguages that best suits it. You need not stick to a single programming\nlanguage for the entire application. If you consider polyglot\npersistence, you can choose the storage mechanism that better suits\nin a component by component basis. It allows a better global scale.\n\nSimilarly, the next thing will be a polyglot cloud. Like above, here you\nchoose a cloud provider that better suits your application in a component\nby component\nbasis. For the majority of your components, you may have to go to your cloud\nprovider. But, this does not stop you from choosing a different one if\nit suits well for any of your application components. So, you can run\ndifferent components of your cloud-native system on different cloud\nproviders based on your requirements.\n\n**Self-sufficient, full-stack teams**\n\nIn a traditional setup, many organizations have teams based on skill sets\nlike backend, user interface, database, operations, etc. Such a\nstructure will not allow you to build cloud-native systems.\n\nIn cloud-native systems, the system is composed of bounded isolated\ncomponents that have their own resources. Each one of such components must\nbe owned by a self-sufficient, full-stack team entirely\nresponsible for all the resources that belong to that particular\ncomponent. In this setup, this team tends to focus on quality upfront as\nthey are the ones who deploy it and they will be taking care of it if\nthe component is broken. It is more like you build it and then you run\nit. So, the team can continuously deliver advancements to the components\nat their own pace. Also, they are completely responsible for delivering\nthese safely.\n\n**Cultural Change**\n\nCloud-native is a different way of thinking. We need to first make up our\nminds, not just the systems, to utilize the full benefits of the cloud.\nCompared to the traditional systems, there will be lots of things we do\ndifferently in cloud-native systems.\n\nTo make that happen, cultural change is really important. To change the\nthinking at a high level, we just to first prove that the low-level\npractices can truly deliver and encourage lean thinking. With these\npractices, you can conduct experimentation. Based on the feedback from\nbusiness, you can quickly and safely deliver your applications that can\nscale.\n\n## Cloud-native Roadmap\n\nYou can define your cloud-native roadmap in many ways. You can get\nthere by choosing different paths. Let us see the trail map defined by\nCNCF.\n\nCNCF defined the Cloud-Native Trail Map providing an overview for\nenterprises starting their cloud-native journey as follows.\n\nThis cloud map gives us various steps that an engineering team may use\nwhile considering the cloud-native technologies and exploring them. The\nmost common ones among them are containerization, CI/CD, and\norchestration. The next crucial pieces will be observability & analysis and\nservice mesh. And later comes the rest of them like networking,\ndistributed database, messaging, container runtime, and software\ndistribution based on your requirements.\n\n![CNCF\\_TrailMap\\_latest.png](./images/CNCF_TrailMap_latest.png)\n\n-   You cannot build cloud-native applications without containerization.\n    This helps your application to run in any computing\n    environment. Basically, all your code and dependencies are packaged\n    up together  into a single unit here. Among the different container\n    platforms available, Docker is the preferred one.\n\n-   It's convenient to set up a CI/CD pipeline to bring all the changes\n    in the code to the container automatically. There are many\n    tools available for this like Jenkins, Travis, etc.\n\n-   We need container orchestration to manage its lifecycles. \n    Kubernetes is a popular solution.\n\n-   Monitoring and observability play a very important role so it's\n    recommended to use techniques like logging, tracing, metrics\n    etc.\n\n-   To enable more complex operational requirements, you can use a\n    service mesh. It helps you out with several things like service\n    discovery, health, routing, A/B testing, etc. Istio is a popular tool.\n\n-   Networking plays a crucial role. You should define flexible\n    networking layers based on your requirements. For this, you can use\n    Calico, Weave Net, etc.\n\n-   Sometimes, you may need distributed databases. These are required\n    if you need more scalability and resiliency.\n\n-   Messaging may be required sometimes too. You can use queues like\n    Kafka, RabbitMQ, etc.\n\n-   Container registry helps you to store all your containers. You can\n    also enable image scanning and signing if required.\n\n-   As a part of your application, sometimes you may need a secure\n    software distribution.\n\nAlso, if you want to see the cloud-native landscape, check it out\n[here](https://landscape.cncf.io/images/landscape.png).\n\n## Summary\n\nIn this section, we covered the fundamentals of cloud-native systems. Now \nyou should know what cloud-native is, why we need it, and how important it is.\nCloud-native is not just deploying your application on the cloud, it's\nalso about taking full advantage of the cloud. Also, with the cloud-native\nroadmap, you will get an idea about how to design and architect your\ncloud-native system. You can also get an overview of the different tools,\nframeworks, platforms, etc. with the cloud-native landscape.\n\nYou can check\n[Cloud Native Applications](https://www.ibm.com/cloud/learn/cloud-native)\nif want to learn more.\n\n## References\n\n-   [Cloud Native Applications](https://www.ibm.com/cloud/learn/cloud-native)\n\n-   [John Gilbert, (2018). Cloud-Native Development Patterns and Best\n    Practices. Publisher: Packt\n    Publishing](https://learning.oreilly.com/library/view/cloud-native-development/9781788473927/)\n\n-   [CNCF landscape](https://github.com/cncf/landscape)\n\n-   [CNCF Definition](https://github.com/cncf/toc/blob/master/DEFINITION.md)\n","fileAbsolutePath":"/workspace/ibm-gsi-cloudnative-journey/src/pages/developer-foundation/cloud-native-overview/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","768070550"]}