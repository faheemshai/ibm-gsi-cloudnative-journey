{"componentChunkName":"component---src-pages-developer-advanced-1-swagger-and-openapi-index-mdx","path":"/developer-advanced-1/swagger-and-openapi/","result":{"pageContext":{"frontmatter":{"title":"Swagger & Open API","description":"Swagger & Open API"},"relativePagePath":"/developer-advanced-1/swagger-and-openapi/index.mdx","titleType":"page","MdxNode":{"id":"5550d454-7386-5dac-a39e-87a3ef9c0a5c","children":[],"parent":"3d8190da-da9c-5d79-a5fd-af709e5d1be2","internal":{"content":"---\ntitle: Swagger & Open API                                                                                 \ndescription: Swagger & Open API\n---\n\nTesting of Web APIs has been always a challenge as it exposes its endpoints rather than showing a UI. Testing Web APIs have a dependency on third-party tools like PostMan.\nSwagger resolves this by providing a UI representation of the RESTful APIs without any implementation logic. Swagger generates UI using the OpenAPI specification (swagger.json) \nbased on service and code.Swagger.json describes capabilities of service.\n\n  \n\n### What is OpenAPI?  \n\n- The OpenAPI Specification is a community-driven open specification within the OpenAPI Initiative, a Linux Foundation Collaborative Project. \n\n- The OpenAPI specification, formerly known as Swgger specification is the world’s standard for describing RESTful APIs.The \"Open API Initiative\" \nis a framework for describing your API using a common language that everyone can understand. \n\n- Think of it as a blueprint for a house. You can use whatever building materials you like, but you can't step outside the parameters of the blueprint.\n\n- An OpenAPI file allows you to describe your entire API, including:\n  - Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)\n  - Operation parameters Input and output for each operation\n  - Authentication methods\n  -\tContact information, license, terms of use and other information.\n\n- The OpenAPI Specification (OAS) defines a standard, programming language-agnostic interface description for HTTP APIs, which allows both humans and computers to \n  discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic.\n\n- When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.\n\n- Similar to what interface descriptions have done for lower-level programming, the OpenAPI Specification removes guesswork in calling a service.\n\n- Use cases for machine-readable API definition documents include, but are not limited to: \n    - interactive documentation\n    - code generation for documentation\n    - clients and servers \n    - automation of test cases. \n\n  ![What can be done using OpenAPI](./images/openapiusage.png)\n\n- OpenAPI documents describe an APIs services and are represented in either YAML or JSON formats. \n\n- These documents may either be produced and served statically or be generated dynamically from an application.\n\n- The OpenAPI Specification does not require rewriting existing APIs. It does not require binding any software to a service — the service being described may not \n  even be owned by the creator of its description.It does, however, require the capabilities of the service be described in the structure of the OpenAPI Specification. \n\n- Not all services can be described by OpenAPI — this specification is not intended to cover every possible style of HTTP APIs, but does include support for REST APIs.\n\n### What is Swagger?\n\nSwagger is the most widely used tooling ecosystem for developing APIs with the OpenAPI Specification (OAS). Swagger consists of both open source as well as professional tools, catering to almost every need and use case.  \nSwagger is in essence an Interface Description Language for describing RESTful APIs expressed using JSON. Swagger is used together with a set of open-source software tools to design, build, document, and use RESTful web services. \nSwagger includes automated documentation, code generation (into many programming languages), and test-case generation. The major Swagger tools include:\n\n- Swagger Editor: It is a browser-based editor where one can write OpenAPI specification. One can write their API documentation in JSON or YAML and have it automatically compared against Open API specification.\n                  Any mistakes are flagged and alternatives are suggested. This way, it is made sure that whenever documentation is published,its error free.\n\n- Swagger UI: It renders OpenAPI specs as interactive API documentation. It takes any OpenAPI specification in JSON or YAML format and creates interactive API documentation out of it.\n\n- Swagger Codegen: It can simplify the build process by generating server stubs and client SDKs for any API,defined with the OpenAPI specification. It saves devlopers from tedious plumbing and configuration by generating boilerplate \n                   servercode in over 20 languages. It generates client SDKs in over 40 different languages.\n\n### Open API vs Swagger\n\n- The Swagger specification development started in 2010, by Wordnik. It was later acquired by SmartBear, in 2015. \n\n- Swagger used to consist of the specification and a large ecosystem of tools to implement the specification. These tools \ninclude everything from front-end user interfaces, low-level code libraries and commercial API management solutions.\n\n- In that same year, SmartBear created the OpenAPI Initiative (OAI) under the Linux Foundation, and donated the Swagger \nspecification to it, in order to advance a common standard across industries. \n\n- A number of tech companies, including Google, IBM, and Microsoft, along with SmartBear signed on as founding members of the OpenAPI Initiative, and the Swagger\nSpecification was rebranded as the Open API Specification.\n\n- The easiest way to understand the difference is:\n  - OpenAPI = Specification\n  -\tSwagger = Tools for implementing the specification\n\n- Swagger is the name associated with some of the most well-known, and widely used tools for implementing the OpenAPI specification.Since the Swagger tools were developed by \n  the team involved in the creation of the original Swagger Specification, the tools are often still viewed as being synonymous with the spec. \n\n- But the Swagger tools are not the only tools that are available for implementing the OpenAPI Specification. There are a wide variety of API design, documentation, testing, \nmanagement, and monitoring solutions that support OpenAPI specification.\n\n\n\n### Benefits of OpenAPI\n\n- Generating interactive documentation: API documentation is often overlooked, but it's crucial for developers to understand how to interact with your endpoints, whether they're internal or external code.\n\n-\tHuman readable and machine readable: This means that not only can this be shared with your team internally, but the same documentation can be used to automate API-dependent processes.The choice of JSON and YAML \n  as the accepted formats is not by accident. Being language-agnostic is an important aspect of the OpenAPI specification widespread use, allowing teams to easily read and share them, while making it easy to create \n  tooling around it for any programming language.\n\n- Creating SDK for multiple languages: A big challenge that API companies face is providing client libraries for multiple languages and frameworks: Node.js, C#, Python, Ruby, Java, etc. \n  OpenAPI tooling such as swagger-codegen helps you do that with little work.\n  \n- Comprehensible for developers and non-developers: Product managers, partners, and even potential clients can have input into the design of your API, because they can see it clearly mapped out in this friendly UI.\n \n-\tEase of use: It is great for testing and debugging API problems.\n\nThese benefits not only make developers' lives easier, but they make the API more consumable. Any API that adheres to the Swagger spec is easy to read, easy to iterate, and easy to consume. \n\n![Benefits of OpenAPI](./images/whyopenapi.png)\n\n\n### Basic structure of Open API file\n\nRoot-level objects in OpenAPI spec\n\nThe OpenAPI 3.0 spec has eight objects at the root level. These eight objects have many nested objects inside them, but at the root level, there are just these parent objects:\n- openapi\n- info\n- servers\n- paths\n- components\n- security\n- tags\n- externalDocs\n\n  ![Root level objects of Open API](./images/rootlevelobj_openapi.png)\n\nThe official description of the OpenAPI specification is available in a Github repository [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#oasObject). Some of the OpenAPI elements are paths, parameters, responses, and security. Each of these elements is a JSON object that holds some properties and arrays.\n\nIn the OpenAPI specification, your endpoints are paths. If you had an endpoint called “pets”, your OpenAPI specification for this endpoint might look as follows:\n\n  ```bash\n        paths:\n         /pets:\n           get:\n             summary: List all pets\n             operationId: listPets\n             tags:\n               - pets\n             parameters:\n               - name: limit\n                 in: query\n                 description: How many items to return at one time (max 100)\n                 required: false\n                 schema:\n                   type: integer\n                   format: int32\n              responses:\n                '200':\n                  description: An paged array of pets\n                  headers:\n                    x-next:\n                      description: A link to the next page of responses\n                      schema:\n                        type: string\n                  content:\n                    application/json:    \n                      schema:\n                        $ref: \"#/components/schemas/Pets\"\n              default:\n                description: unexpected error\n                content:\n                  application/json:\n                    schema:\n                      $ref: \"#/components/schemas/Error\"\n  ```\n\nHere’s what these objects mean:\n\n- /pets is the endpoint path.\n- get is the HTTP method.\n- parameters lists the parameters for the endpoint.\n- responses lists the response from the request.\n- 200 is the HTTP status code.\n- $ref is a reference to another part of your implementation where the response is defined (in components). OpenAPI has a lot of $ref markers like this to keep your code clean and to facilitate re-use.\n\nYou can do some practical exercises and get a better understanding of [openapi and swagger](/developer-advanced-1/swagger-and-openapi-handson/)\n\n\nReferences:\n- https://www.youtube.com/watch?v=EZg6PkWiSBo\n- https://idratherbewriting.com/learnapidoc/\n- https://swagger.io/tools/open-source/getting-started/\n- https://blog.readme.com/what-is-swagger-and-why-it-matters/\n- https://en.wikipedia.org/wiki/OpenAPI_Specification\n- swagger.io\n- www.openapis.org\n\n\n\n\n\n","type":"Mdx","contentDigest":"dbacedf0904d389278e607c3f6da7f9c","owner":"gatsby-plugin-mdx","counter":937},"frontmatter":{"title":"Swagger & Open API","description":"Swagger & Open API"},"exports":{},"rawBody":"---\ntitle: Swagger & Open API                                                                                 \ndescription: Swagger & Open API\n---\n\nTesting of Web APIs has been always a challenge as it exposes its endpoints rather than showing a UI. Testing Web APIs have a dependency on third-party tools like PostMan.\nSwagger resolves this by providing a UI representation of the RESTful APIs without any implementation logic. Swagger generates UI using the OpenAPI specification (swagger.json) \nbased on service and code.Swagger.json describes capabilities of service.\n\n  \n\n### What is OpenAPI?  \n\n- The OpenAPI Specification is a community-driven open specification within the OpenAPI Initiative, a Linux Foundation Collaborative Project. \n\n- The OpenAPI specification, formerly known as Swgger specification is the world’s standard for describing RESTful APIs.The \"Open API Initiative\" \nis a framework for describing your API using a common language that everyone can understand. \n\n- Think of it as a blueprint for a house. You can use whatever building materials you like, but you can't step outside the parameters of the blueprint.\n\n- An OpenAPI file allows you to describe your entire API, including:\n  - Available endpoints (/users) and operations on each endpoint (GET /users, POST /users)\n  - Operation parameters Input and output for each operation\n  - Authentication methods\n  -\tContact information, license, terms of use and other information.\n\n- The OpenAPI Specification (OAS) defines a standard, programming language-agnostic interface description for HTTP APIs, which allows both humans and computers to \n  discover and understand the capabilities of a service without requiring access to source code, additional documentation, or inspection of network traffic.\n\n- When properly defined via OpenAPI, a consumer can understand and interact with the remote service with a minimal amount of implementation logic.\n\n- Similar to what interface descriptions have done for lower-level programming, the OpenAPI Specification removes guesswork in calling a service.\n\n- Use cases for machine-readable API definition documents include, but are not limited to: \n    - interactive documentation\n    - code generation for documentation\n    - clients and servers \n    - automation of test cases. \n\n  ![What can be done using OpenAPI](./images/openapiusage.png)\n\n- OpenAPI documents describe an APIs services and are represented in either YAML or JSON formats. \n\n- These documents may either be produced and served statically or be generated dynamically from an application.\n\n- The OpenAPI Specification does not require rewriting existing APIs. It does not require binding any software to a service — the service being described may not \n  even be owned by the creator of its description.It does, however, require the capabilities of the service be described in the structure of the OpenAPI Specification. \n\n- Not all services can be described by OpenAPI — this specification is not intended to cover every possible style of HTTP APIs, but does include support for REST APIs.\n\n### What is Swagger?\n\nSwagger is the most widely used tooling ecosystem for developing APIs with the OpenAPI Specification (OAS). Swagger consists of both open source as well as professional tools, catering to almost every need and use case.  \nSwagger is in essence an Interface Description Language for describing RESTful APIs expressed using JSON. Swagger is used together with a set of open-source software tools to design, build, document, and use RESTful web services. \nSwagger includes automated documentation, code generation (into many programming languages), and test-case generation. The major Swagger tools include:\n\n- Swagger Editor: It is a browser-based editor where one can write OpenAPI specification. One can write their API documentation in JSON or YAML and have it automatically compared against Open API specification.\n                  Any mistakes are flagged and alternatives are suggested. This way, it is made sure that whenever documentation is published,its error free.\n\n- Swagger UI: It renders OpenAPI specs as interactive API documentation. It takes any OpenAPI specification in JSON or YAML format and creates interactive API documentation out of it.\n\n- Swagger Codegen: It can simplify the build process by generating server stubs and client SDKs for any API,defined with the OpenAPI specification. It saves devlopers from tedious plumbing and configuration by generating boilerplate \n                   servercode in over 20 languages. It generates client SDKs in over 40 different languages.\n\n### Open API vs Swagger\n\n- The Swagger specification development started in 2010, by Wordnik. It was later acquired by SmartBear, in 2015. \n\n- Swagger used to consist of the specification and a large ecosystem of tools to implement the specification. These tools \ninclude everything from front-end user interfaces, low-level code libraries and commercial API management solutions.\n\n- In that same year, SmartBear created the OpenAPI Initiative (OAI) under the Linux Foundation, and donated the Swagger \nspecification to it, in order to advance a common standard across industries. \n\n- A number of tech companies, including Google, IBM, and Microsoft, along with SmartBear signed on as founding members of the OpenAPI Initiative, and the Swagger\nSpecification was rebranded as the Open API Specification.\n\n- The easiest way to understand the difference is:\n  - OpenAPI = Specification\n  -\tSwagger = Tools for implementing the specification\n\n- Swagger is the name associated with some of the most well-known, and widely used tools for implementing the OpenAPI specification.Since the Swagger tools were developed by \n  the team involved in the creation of the original Swagger Specification, the tools are often still viewed as being synonymous with the spec. \n\n- But the Swagger tools are not the only tools that are available for implementing the OpenAPI Specification. There are a wide variety of API design, documentation, testing, \nmanagement, and monitoring solutions that support OpenAPI specification.\n\n\n\n### Benefits of OpenAPI\n\n- Generating interactive documentation: API documentation is often overlooked, but it's crucial for developers to understand how to interact with your endpoints, whether they're internal or external code.\n\n-\tHuman readable and machine readable: This means that not only can this be shared with your team internally, but the same documentation can be used to automate API-dependent processes.The choice of JSON and YAML \n  as the accepted formats is not by accident. Being language-agnostic is an important aspect of the OpenAPI specification widespread use, allowing teams to easily read and share them, while making it easy to create \n  tooling around it for any programming language.\n\n- Creating SDK for multiple languages: A big challenge that API companies face is providing client libraries for multiple languages and frameworks: Node.js, C#, Python, Ruby, Java, etc. \n  OpenAPI tooling such as swagger-codegen helps you do that with little work.\n  \n- Comprehensible for developers and non-developers: Product managers, partners, and even potential clients can have input into the design of your API, because they can see it clearly mapped out in this friendly UI.\n \n-\tEase of use: It is great for testing and debugging API problems.\n\nThese benefits not only make developers' lives easier, but they make the API more consumable. Any API that adheres to the Swagger spec is easy to read, easy to iterate, and easy to consume. \n\n![Benefits of OpenAPI](./images/whyopenapi.png)\n\n\n### Basic structure of Open API file\n\nRoot-level objects in OpenAPI spec\n\nThe OpenAPI 3.0 spec has eight objects at the root level. These eight objects have many nested objects inside them, but at the root level, there are just these parent objects:\n- openapi\n- info\n- servers\n- paths\n- components\n- security\n- tags\n- externalDocs\n\n  ![Root level objects of Open API](./images/rootlevelobj_openapi.png)\n\nThe official description of the OpenAPI specification is available in a Github repository [here](https://github.com/OAI/OpenAPI-Specification/blob/master/versions/3.0.3.md#oasObject). Some of the OpenAPI elements are paths, parameters, responses, and security. Each of these elements is a JSON object that holds some properties and arrays.\n\nIn the OpenAPI specification, your endpoints are paths. If you had an endpoint called “pets”, your OpenAPI specification for this endpoint might look as follows:\n\n  ```bash\n        paths:\n         /pets:\n           get:\n             summary: List all pets\n             operationId: listPets\n             tags:\n               - pets\n             parameters:\n               - name: limit\n                 in: query\n                 description: How many items to return at one time (max 100)\n                 required: false\n                 schema:\n                   type: integer\n                   format: int32\n              responses:\n                '200':\n                  description: An paged array of pets\n                  headers:\n                    x-next:\n                      description: A link to the next page of responses\n                      schema:\n                        type: string\n                  content:\n                    application/json:    \n                      schema:\n                        $ref: \"#/components/schemas/Pets\"\n              default:\n                description: unexpected error\n                content:\n                  application/json:\n                    schema:\n                      $ref: \"#/components/schemas/Error\"\n  ```\n\nHere’s what these objects mean:\n\n- /pets is the endpoint path.\n- get is the HTTP method.\n- parameters lists the parameters for the endpoint.\n- responses lists the response from the request.\n- 200 is the HTTP status code.\n- $ref is a reference to another part of your implementation where the response is defined (in components). OpenAPI has a lot of $ref markers like this to keep your code clean and to facilitate re-use.\n\nYou can do some practical exercises and get a better understanding of [openapi and swagger](/developer-advanced-1/swagger-and-openapi-handson/)\n\n\nReferences:\n- https://www.youtube.com/watch?v=EZg6PkWiSBo\n- https://idratherbewriting.com/learnapidoc/\n- https://swagger.io/tools/open-source/getting-started/\n- https://blog.readme.com/what-is-swagger-and-why-it-matters/\n- https://en.wikipedia.org/wiki/OpenAPI_Specification\n- swagger.io\n- www.openapis.org\n\n\n\n\n\n","fileAbsolutePath":"/workspace/ibm-gsi-cloudnative-journey/src/pages/developer-advanced-1/swagger-and-openapi/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","768070550"]}