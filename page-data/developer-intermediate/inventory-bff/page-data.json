{"componentChunkName":"component---src-pages-developer-intermediate-inventory-bff-index-mdx","path":"/developer-intermediate/inventory-bff/","result":{"pageContext":{"frontmatter":{"title":"Inventory BFF"},"relativePagePath":"/developer-intermediate/inventory-bff/index.mdx","titleType":"page","MdxNode":{"id":"39af8383-7f8d-5e22-8d89-44757166dd71","children":[],"parent":"ab5dc5ce-cab7-5112-9834-7707a60ad7ff","internal":{"content":"---\ntitle: Inventory BFF\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nDevelop and deploy the BFF component of the inventory application\n\n</PageDescription>\n\n#### Setup\n\nThe Inventory BFF's role in the architecture is to act as an orchestrator between the core business services and the specific digital channel it is focused on supporting. This class article will give you more detail about the architectural pattern and the benefits. [Backend for Frontend](https://samnewman.io/patterns/architectural/bff/)\n\nThe Inventory solution will use [GraphQL](https://graphql.org/) for its BFF layer, which enables the API to be dynamically controlled from the client using API queries. Follow the steps below to get started.\n\n#### Setup\n\nTo get the initial BFF project created and registered with a pipeline for automated builds follow these steps.\n\n- Create a new repository from the [Typescript GraphQL <Globals name=\"template\" />](https://github.com/IBM/template-graphql-typescript/generate)\n\n    <InlineNotification kind=\"warning\">\n\n    **Warning:** If you are developing on a shared education cluster place the repository in the  **Git Organisation** listed in your notification email and remember to add your initials as a suffix to the app name.\n\n    </InlineNotification>\n\n    - In order to prevent naming collisions, name the repository `inventory-management-bff-{your initials}` replacing\n    `{your initials}` with your actual initials.\n\n- Clone the new repository to your machine\n\n- Run `npm install` to install all the package dependencies\n\n- Go into the repository directory cloned and execute the following\n\n    ```\n    oc sync dev-{your initials} --dev\n    ```\n\n- Register the pipeline [register the pipeline](/developer-intermediate/deploy-app#register-the-app-in-a-devops-pipeline)\n\n    ```\n    oc pipeline --tekton\n    ```\n\n   replacing `{your initials}` with your actual initials\n\n- Execution of the above command. Give git credentials if prompted, and master as the git branch to use. When prompted for the pipeline, select igc-nodejs-v1-2-0.\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#9.-view-your-application-pipeline)\n\n- When the pipeline is completed, run `oc endpoints -n dev-{your initials}`. You should see an entry\nfor the app we just pushed. Select the entry and hit `Enter` to launch the browser, if you are working\non your desktop/laptop. Otherwise copy the url and paste it in a new browser tab.\n\n#### Build the controller for the REST interface\n\nThe controller provides the REST interface for our BFF. The <Globals name=\"template\" /> uses the `typescript-rest`\npackage to simplify the tasks required to create a controller.\n\n- Start the tests in tdd mode by running\n\n```bash\nnpm run tdd\n```\n\n- Create the controller test\n\n```typescript path=test/controllers/stock-items.controller.spec.ts\nimport {Application} from 'express';\nimport * as request from 'supertest';\n\nimport {buildApiServer} from '../helper';\n\ndescribe('stock-item.controller', () => {\n\n  let app: Application;\n  beforeEach(async () => {\n    const apiServer = buildApiServer();\n\n    app = await apiServer.getApp();\n  });\n\n  test('canary verifies test infrastructure', () => {\n     expect(true).toEqual(true);\n  });\n\n  describe('given GET /stock-items', () => {\n    describe('when service is successful', () => {\n      test('then return 200 status', async () => {\n        return request(app).get('/stock-items').expect(200);\n      });\n\n      test('then should return an empty array', async () => {\n        return request(app).get('/stock-items').expect([]);\n      });\n    });\n  });\n});\n```\n\n- Create the controller component\n\n```typescript path=src/controllers/stock-items.controller.ts\nimport {GET, Path} from 'typescript-rest';\n\n@Path('stock-items')\nexport class StockItemsController {\n\n  @GET\n  async listStockItems(): Promise<any[]> {\n    return [];\n  }\n}\n```\n\n- Add the controller to the controllers `index.ts`. (Using `index.ts` is a good way to manage which components are exposed\nby a component and provide a good way to load the modules that will be injected into other components)\n\n```typescript path=src/controllers/index.ts\nexport * from './health.controller';\nexport * from './stock-items.controller';\n```\n\n- Start the service to see it running\n\n```bash\nnpm start\n```\n<Tabs>\n\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwopenapp.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n\n\n<Tab label=\"Desktop/Laptop\">\n- Open a browser to `http://localhost:3000/api-docs` to see the swagger page\n</Tab>\n\n</Tabs>\n\n- Expand our service from the list, click `Try it out`, then click `Execute`\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds stock items controller\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#9.-view-your-application-pipeline)\n\n#### Update the controller to call a service\n\nThe pattern recommended for the REST controllers is to let it focus on translating REST protocols\ninto javascript and to put the business logic in a separate service component.\n\n- Add a StockItem model that contains the values needed for the UI\n\n```typescript path=src/models/stock-item.model.ts\nexport class StockItemModel {\n  id: string;\n  name: string;\n  description: string;\n  stock: number;\n  unitPrice: number;\n  picture: string;\n  manufacturer: string;\n}\n```\n\n- Register the model with the `index.ts` file in the models directory. Append this to end of the file.\n\n```typescript path=src/models/index.ts\n...\nexport * from './stock-item.model';\n```\n\n- Define an abstract class to provide the interface for our API\n\n```typescript path=src/services/stock-items.api.ts\nimport {StockItemModel} from '../models';\n\nexport abstract class StockItemsApi {\n  async abstract listStockItems(): Promise<StockItemModel[]>;\n}\n```\n\n<InlineNotification>\n\n**Why an abstract class and not an interface?**\n\nTypeScript introduces both abstract classes and interfaces. When TypeScript gets transpiled into\nJavaScript, abstract classes are generated as classes but interfaces disappear since there isn't an equivalent type\nin JavaScript. As a result, they cannot be used as a binding type for the `typescript-ioc` framework. Fortunately,\nabstract classes can be used and they have the quirky behavior in TypeScript allowing them to either be `extended`\nlike a class or `implemented` like an interface.\n\n</InlineNotification>\n\n- Add the abstract class to the `index.ts` file in the services directory. Add it to the end of other export statements, do not overwrite the file.\n\n```typescript path=src/services/index.ts\n...\n\nexport * from './stock-items.api';\n\n...\n```\n\n- Update the controller test to inject the service into the controller and to return the value from the service\n\n```typescript path=test/controllers/stock-items.controller.spec.ts\nimport {Application} from 'express';\nimport * as request from 'supertest';\nimport {Container} from 'typescript-ioc';\n\nimport {buildApiServer} from '../helper';\nimport Mock = jest.Mock;\nimport {StockItemsMockService} from '../../src/services';\n\ndescribe('stock-item.controller', () => {\n\n  let app: Application;\n  let service_listStockItems: Mock;\n\n   beforeEach(async () => {\n    service_listStockItems = jest.fn();\n    Container.bind(StockItemsMockService).factory(\n      () => ({\n        listStockItems: service_listStockItems\n      }),\n    );\n\n    const apiServer = buildApiServer();\n\n    app = await apiServer.getApp();\n  });\n\n\n  test('canary verifies test infrastructure', () => {\n     expect(true).toEqual(true);\n  });\n\n  describe('given GET /stock-items', () => {\n    describe('when service is successful', () => {\n      const expectedResult = [{value: 'val'}];\n      beforeEach(() => {\n        service_listStockItems.mockResolvedValue(expectedResult);\n      });\n\n      test('then return 200 status', async () => {\n        return request(app).get('/stock-items').expect(200);\n      });\n\n      test('then should return value from service', async () => {\n        return request(app).get('/stock-items').expect(expectedResult);\n      });\n    });\n\n    describe('when service fails', () => {\n      beforeEach(() => {\n        service_listStockItems.mockRejectedValue(new Error('service failed'));\n      });\n\n      test('then return 502 error', async () => {\n        return request(app).get('/stock-items').expect(502);\n      });\n    });\n  });\n});\n```\n\n- Update the controller to inject the service and use it\n\n```typescript path=src/controllers/stock-items.controller.ts\nimport {Inject} from 'typescript-ioc';\nimport {GET, Path} from 'typescript-rest';\nimport {HttpError} from 'typescript-rest/dist/server/model/errors';\n\nimport {StockItemModel} from '../models';\nimport {StockItemsMockService} from '../services';\n\nclass BadGateway extends HttpError {\n  constructor(message?: string) {\n    super(\"BadGateway\", message);\n    this.statusCode = 502;\n  }\n}\n\n@Path('stock-items')\nexport class StockItemsController {\n  @Inject\n  service: StockItemsMockService;\n\n  @GET\n  async listStockItems(): Promise<StockItemModel[]> {\n    try {\n      return await this.service.listStockItems();\n    } catch (err) {\n      throw new BadGateway('There was an error');\n    }\n  }\n}\n```\n\n#### Create a mock service implementation\n\nNow that we have our Controller using our API to get the data, lets create an implementation that will provide\nmock data for now.\n\n- Add a `stock-items-mock.service` to services\n\n```typescript path=src/services/stock-items-mock.service.ts\nimport {StockItemsApi} from './stock-items.api';\nimport {StockItemModel} from '../models';\n\n\nexport class StockItemsMockService implements StockItemsApi {\n  async listStockItems(): Promise<StockItemModel[]> {\n    return [\n      {\n        id: \"1\",\n        name: \"Self-sealing stem bolt\",\n        description: \"Self-sealing stem bolt\",\n        stock: 10,\n        unitPrice: 10.5,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Bajor Galactic\"\n      },\n      {\n        id: \"2\",\n        name: \"Heisenberg compensator\",\n        description: \"Magical component that negates the effects of the Heisenberg Uncertainty Principle\",\n        stock: 20,\n        unitPrice: 20.0,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Federation Imports\"\n      },\n      {\n        id: \"3\",\n        name: \"Tooth sharpener\",\n        description: \"Industrial strength tooth sharpener\",\n        stock: 30,\n        unitPrice: 5.25,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Farenginar Exploits\"\n      }\n    ];\n  }\n}\n```\n\n- Add the mock service to the `index.ts` file in the services directory\n\n```typescript path=src/services/index.ts\n...\nexport * from './stock-items-mock.service';\n...\n```\n\n- Start the service\n\n```bash\nnpm start\n```\n<Tabs>\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwopenapp.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n<Tab label=\"Desktop/Laptop\">\n- Open a browser to `http://localhost:3000/api-docs` and execute the stock items controller. You should see the data from\nabove returned by the service.\n</Tab>\n</Tabs>\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds a mock service implementation\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n#### Add a GraphQL implementation of Stock Items\n\nThe GraphQL <Globals name=\"template\" /> supports both REST and GraphQL APIs for accessing backend services. We created\na REST controller to expose the results from the service and now we will do the same\nfor GraphQL.\n\n- Create a `stock-items` GraphQL schema in the `schemas` directory\n\n```typescript path=src/schemas/stock-item.schema.ts\nimport {Field, Float, Int, ObjectType} from 'type-graphql';\nimport {StockItemModel} from '../models';\n\n@ObjectType()\nexport class StockItem implements StockItemModel {\n  @Field()\n  id: string;\n  @Field()\n  description: string;\n  @Field()\n  manufacturer: string;\n  @Field()\n  name: string;\n  @Field({nullable: true})\n  picture: string;\n  @Field(type => Int)\n  stock: number;\n  @Field(type => Float)\n  unitPrice: number;\n}\n```\n\n- Add the stock-items schema to the `index.ts` in the schemas directory\n\n```typescript path=src/schemas/index.ts\nexport * from './stock-item.schema'\n```\n\n- Add a 'stock-item' GraphQL resolver in the `resolvers` directory\n\n```typescript path=src/resolvers/stock-item.resolver.ts\nimport {Query, Resolver} from 'type-graphql';\nimport {Inject} from 'typescript-ioc';\n\nimport {resolverManager} from './_resolver-manager';\nimport {StockItem} from '../schemas';\nimport {StockItemModel} from '../models';\nimport {StockItemsMockService} from '../services';\n\n@Resolver(of => StockItem)\nexport class StockItemResolver {\n  @Inject\n  service: StockItemsMockService;\n\n  @Query(returns => [StockItem])\n  async stockItems(): Promise<StockItemModel[]> {\n    return this.service.listStockItems();\n  }\n}\n\nresolverManager.registerResolver(StockItemResolver);\n```\n\n<InlineNotification>\n\n**Note:** The <Globals name=\"template\" /> includes a `resolverManager` component that simplifies the steps to\nmake the resolver available. All that is required to use the resolver is to register it, preferably\nat the bottom of the module where it is defined.\n\n</InlineNotification>\n\n- Add the stock-items resolver to `index.ts` in the resolvers directory\n\n```typescript path=src/resolvers/index.ts\nexport * from './stock-item.resolver';\n```\n\n- Start the service\n\n```bash\nnpm start\n```\n- Verify that the that the resolver is available using the Graph QL browser provided by the <Globals name=\"template\" />\n    - Open GraphQL Playground: `http://localhost:3000`\n    - Run the query `query { stockItems { name } }`\n    \n<Tabs>\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwgraphql.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n<Tab label=\"Desktop/Laptop\">\n- Open GraphQL Playground: `http://localhost:3000`\n\n</Tab>\n\n\n\n\n</Tabs>\n\n\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds a graphql interface\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n#### Create a service implementation that calls the microservice\n\n- Create a folder `config` in following path `src/config`\n\n- Add a `stock-item-service.config` file in the config directory\n\n```typescript path=src/config/stock-item-service.config.ts\nexport class StockItemServiceConfig {\n  baseUrl: string;\n}\n```\n- Add a `stock-item-service.config.provider` file in the config directory\n\n```typescript path=src/config/stock-item-service.config.provider.ts\nimport {ObjectFactory} from 'typescript-ioc';\n\nconst baseUrl: string = process.env.SERVICE_URL || 'localhost:9080';\n\nexport const stockItemConfigFactory: ObjectFactory = () => ({\n  baseUrl,\n});\n```\n\nThe config class separates how the config is loaded from how it is used. In this case the config is simply\nretrieved from an environment variable but in more complex cases the value(s) can be retrived from external\ndata sources.\n\n- Add the `stock-item-service.config` to an index.ts of the config directory\n\n```typescript path=src/config/index.ts\nimport {StockItemServiceConfig} from './stock-item-service.config';\nimport {stockItemConfigFactory} from './stock-item-service.config.provider';\nimport {Container} from 'typescript-ioc';\n\nexport * from './stock-item-service.config';\n\nContainer.bind(StockItemServiceConfig).factory(stockItemConfigFactory);\n```\n\n- Create a `stock-items` service in the services directory that uses the config\n\n```typescript path=src/services/stock-items.service.ts\nimport {Inject} from 'typescript-ioc';\nimport {get, Response} from 'superagent';\n\nimport {StockItemsApi} from './stock-items.api';\nimport {StockItemModel} from '../models';\nimport {StockItemServiceConfig} from '../config';\nimport {LoggerApi} from '../logger';\n\nclass StockItem {\n  'id'?: string;\n  'manufacturer'?: string;\n  'name'?: string;\n  'price'?: number;\n  'stock'?: number;\n}\n\nexport class StockItemsService implements StockItemsApi {\n  @Inject\n  _logger: LoggerApi;\n  @Inject\n  config: StockItemServiceConfig;\n\n  get logger(): LoggerApi {\n    return this._logger.child('StockItemsService');\n  }\n\n  async listStockItems(): Promise<StockItemModel[]> {\n    try {\n      const response: Response = await get(this.config.baseUrl + '/stock-items')\n        .set('Accept', 'application/json');\n\n      return this.mapStockItems(response.body);\n    } catch (err) {\n      this.logger.error('Error getting data from service', err);\n      throw err;\n    }\n  }\n\n  mapStockItems(data: StockItem[]): StockItemModel[] {\n    return data.map(this.mapStockItem);\n  }\n\n  mapStockItem(item: StockItem): StockItemModel {\n    return {\n      id: item.id,\n      name: item.name,\n      description: item.name,\n      stock: item.stock,\n      unitPrice: item.price,\n      picture: 'https://via.placeholder.com/32.png',\n      manufacturer: item.manufacturer,\n    };\n  }\n}\n```\n\n- Add `stock-item.service` to `index.ts` in the service directory\n- Add `StockItemsService` instead of `StockItemsMockService` in the following files `src/resolvers/stock-item.resolver.ts` ,\n  `src/controllers/stock-items.controller.ts` and `test/controllers/stock-items.controller.spec.ts`\n\n\n- Remove `stock-items-mock.service` from `index.ts`\n\n```typescript path=src/services/index.ts\nexport * from './stock-items.service';\n```\n\n\n- Modify `connectsTo` property to the values.yaml file of the Helm chart. The value of the property should match the\nKubernetes service of the microservice. (For <Globals name=\"template\" /> projects, the service name is the same as the name of the\napplication which is that same as the name of the repository.)\n\n```yaml path=chart/base/values.yaml\n...\n\nconnectsTo: inventory-management-svc-{your initials}\n\n...\n```\n\nThe `values.yaml` file of the Helm chart defines the variables that can be provided to the\ntemplate as input. Now that we've added a new variable, we will need to update the appropriate\ntemplate file to use our new variable.\n\n- Add a new environment variable named `SERVICE_URL` to the list of existing environment variables in deployment.yaml.\n(`SERVICE_URL` is the name we gave the environment variable in our `stock-item-service.config` class as the first step in\nthis section.) The value of this environment variable should come from the `connectsTo` value we defined. You can add\n`| quote` to wrap the value in quotes in case the value is not formatted correctly.\n\n```yaml path=chart/base/templates/deployment.yaml\n  ...\n  env:\n    - name: INGRESS_HOST\n      value: \"\"\n    - name: PROTOCOLS\n      value: \"\"\n    - name: LOG_LEVEL\n      value: {{ .Values.logLevel | quote }}\n    - name: SERVICE_URL\n      value: {{ printf \"%s:80\" .Values.connectsTo | quote }}\n  ...\n```\n\n`deployment.yaml` is a templatized Kubernetes yaml file that describes the deployment of our component.\nThe deployment will create one or more pods based on the pod template defined in the deployment.\nEach pod that starts will have the envionment variables that we have defined in the `env` section\navailable for the container image to reference.\n\n- Commit and push the changes to git\n\n```bash\ngit add .\ngit commit -m \"Adds service implementation\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n","type":"Mdx","contentDigest":"4cbc84b4e65d971efe3937b8f1e65370","owner":"gatsby-plugin-mdx","counter":1012},"frontmatter":{"title":"Inventory BFF"},"exports":{},"rawBody":"---\ntitle: Inventory BFF\n---\n\nimport Globals from 'gatsby-theme-carbon/src/templates/Globals';\n\n<PageDescription>\n\nDevelop and deploy the BFF component of the inventory application\n\n</PageDescription>\n\n#### Setup\n\nThe Inventory BFF's role in the architecture is to act as an orchestrator between the core business services and the specific digital channel it is focused on supporting. This class article will give you more detail about the architectural pattern and the benefits. [Backend for Frontend](https://samnewman.io/patterns/architectural/bff/)\n\nThe Inventory solution will use [GraphQL](https://graphql.org/) for its BFF layer, which enables the API to be dynamically controlled from the client using API queries. Follow the steps below to get started.\n\n#### Setup\n\nTo get the initial BFF project created and registered with a pipeline for automated builds follow these steps.\n\n- Create a new repository from the [Typescript GraphQL <Globals name=\"template\" />](https://github.com/IBM/template-graphql-typescript/generate)\n\n    <InlineNotification kind=\"warning\">\n\n    **Warning:** If you are developing on a shared education cluster place the repository in the  **Git Organisation** listed in your notification email and remember to add your initials as a suffix to the app name.\n\n    </InlineNotification>\n\n    - In order to prevent naming collisions, name the repository `inventory-management-bff-{your initials}` replacing\n    `{your initials}` with your actual initials.\n\n- Clone the new repository to your machine\n\n- Run `npm install` to install all the package dependencies\n\n- Go into the repository directory cloned and execute the following\n\n    ```\n    oc sync dev-{your initials} --dev\n    ```\n\n- Register the pipeline [register the pipeline](/developer-intermediate/deploy-app#register-the-app-in-a-devops-pipeline)\n\n    ```\n    oc pipeline --tekton\n    ```\n\n   replacing `{your initials}` with your actual initials\n\n- Execution of the above command. Give git credentials if prompted, and master as the git branch to use. When prompted for the pipeline, select igc-nodejs-v1-2-0.\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#9.-view-your-application-pipeline)\n\n- When the pipeline is completed, run `oc endpoints -n dev-{your initials}`. You should see an entry\nfor the app we just pushed. Select the entry and hit `Enter` to launch the browser, if you are working\non your desktop/laptop. Otherwise copy the url and paste it in a new browser tab.\n\n#### Build the controller for the REST interface\n\nThe controller provides the REST interface for our BFF. The <Globals name=\"template\" /> uses the `typescript-rest`\npackage to simplify the tasks required to create a controller.\n\n- Start the tests in tdd mode by running\n\n```bash\nnpm run tdd\n```\n\n- Create the controller test\n\n```typescript path=test/controllers/stock-items.controller.spec.ts\nimport {Application} from 'express';\nimport * as request from 'supertest';\n\nimport {buildApiServer} from '../helper';\n\ndescribe('stock-item.controller', () => {\n\n  let app: Application;\n  beforeEach(async () => {\n    const apiServer = buildApiServer();\n\n    app = await apiServer.getApp();\n  });\n\n  test('canary verifies test infrastructure', () => {\n     expect(true).toEqual(true);\n  });\n\n  describe('given GET /stock-items', () => {\n    describe('when service is successful', () => {\n      test('then return 200 status', async () => {\n        return request(app).get('/stock-items').expect(200);\n      });\n\n      test('then should return an empty array', async () => {\n        return request(app).get('/stock-items').expect([]);\n      });\n    });\n  });\n});\n```\n\n- Create the controller component\n\n```typescript path=src/controllers/stock-items.controller.ts\nimport {GET, Path} from 'typescript-rest';\n\n@Path('stock-items')\nexport class StockItemsController {\n\n  @GET\n  async listStockItems(): Promise<any[]> {\n    return [];\n  }\n}\n```\n\n- Add the controller to the controllers `index.ts`. (Using `index.ts` is a good way to manage which components are exposed\nby a component and provide a good way to load the modules that will be injected into other components)\n\n```typescript path=src/controllers/index.ts\nexport * from './health.controller';\nexport * from './stock-items.controller';\n```\n\n- Start the service to see it running\n\n```bash\nnpm start\n```\n<Tabs>\n\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwopenapp.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n\n\n<Tab label=\"Desktop/Laptop\">\n- Open a browser to `http://localhost:3000/api-docs` to see the swagger page\n</Tab>\n\n</Tabs>\n\n- Expand our service from the list, click `Try it out`, then click `Execute`\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds stock items controller\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#9.-view-your-application-pipeline)\n\n#### Update the controller to call a service\n\nThe pattern recommended for the REST controllers is to let it focus on translating REST protocols\ninto javascript and to put the business logic in a separate service component.\n\n- Add a StockItem model that contains the values needed for the UI\n\n```typescript path=src/models/stock-item.model.ts\nexport class StockItemModel {\n  id: string;\n  name: string;\n  description: string;\n  stock: number;\n  unitPrice: number;\n  picture: string;\n  manufacturer: string;\n}\n```\n\n- Register the model with the `index.ts` file in the models directory. Append this to end of the file.\n\n```typescript path=src/models/index.ts\n...\nexport * from './stock-item.model';\n```\n\n- Define an abstract class to provide the interface for our API\n\n```typescript path=src/services/stock-items.api.ts\nimport {StockItemModel} from '../models';\n\nexport abstract class StockItemsApi {\n  async abstract listStockItems(): Promise<StockItemModel[]>;\n}\n```\n\n<InlineNotification>\n\n**Why an abstract class and not an interface?**\n\nTypeScript introduces both abstract classes and interfaces. When TypeScript gets transpiled into\nJavaScript, abstract classes are generated as classes but interfaces disappear since there isn't an equivalent type\nin JavaScript. As a result, they cannot be used as a binding type for the `typescript-ioc` framework. Fortunately,\nabstract classes can be used and they have the quirky behavior in TypeScript allowing them to either be `extended`\nlike a class or `implemented` like an interface.\n\n</InlineNotification>\n\n- Add the abstract class to the `index.ts` file in the services directory. Add it to the end of other export statements, do not overwrite the file.\n\n```typescript path=src/services/index.ts\n...\n\nexport * from './stock-items.api';\n\n...\n```\n\n- Update the controller test to inject the service into the controller and to return the value from the service\n\n```typescript path=test/controllers/stock-items.controller.spec.ts\nimport {Application} from 'express';\nimport * as request from 'supertest';\nimport {Container} from 'typescript-ioc';\n\nimport {buildApiServer} from '../helper';\nimport Mock = jest.Mock;\nimport {StockItemsMockService} from '../../src/services';\n\ndescribe('stock-item.controller', () => {\n\n  let app: Application;\n  let service_listStockItems: Mock;\n\n   beforeEach(async () => {\n    service_listStockItems = jest.fn();\n    Container.bind(StockItemsMockService).factory(\n      () => ({\n        listStockItems: service_listStockItems\n      }),\n    );\n\n    const apiServer = buildApiServer();\n\n    app = await apiServer.getApp();\n  });\n\n\n  test('canary verifies test infrastructure', () => {\n     expect(true).toEqual(true);\n  });\n\n  describe('given GET /stock-items', () => {\n    describe('when service is successful', () => {\n      const expectedResult = [{value: 'val'}];\n      beforeEach(() => {\n        service_listStockItems.mockResolvedValue(expectedResult);\n      });\n\n      test('then return 200 status', async () => {\n        return request(app).get('/stock-items').expect(200);\n      });\n\n      test('then should return value from service', async () => {\n        return request(app).get('/stock-items').expect(expectedResult);\n      });\n    });\n\n    describe('when service fails', () => {\n      beforeEach(() => {\n        service_listStockItems.mockRejectedValue(new Error('service failed'));\n      });\n\n      test('then return 502 error', async () => {\n        return request(app).get('/stock-items').expect(502);\n      });\n    });\n  });\n});\n```\n\n- Update the controller to inject the service and use it\n\n```typescript path=src/controllers/stock-items.controller.ts\nimport {Inject} from 'typescript-ioc';\nimport {GET, Path} from 'typescript-rest';\nimport {HttpError} from 'typescript-rest/dist/server/model/errors';\n\nimport {StockItemModel} from '../models';\nimport {StockItemsMockService} from '../services';\n\nclass BadGateway extends HttpError {\n  constructor(message?: string) {\n    super(\"BadGateway\", message);\n    this.statusCode = 502;\n  }\n}\n\n@Path('stock-items')\nexport class StockItemsController {\n  @Inject\n  service: StockItemsMockService;\n\n  @GET\n  async listStockItems(): Promise<StockItemModel[]> {\n    try {\n      return await this.service.listStockItems();\n    } catch (err) {\n      throw new BadGateway('There was an error');\n    }\n  }\n}\n```\n\n#### Create a mock service implementation\n\nNow that we have our Controller using our API to get the data, lets create an implementation that will provide\nmock data for now.\n\n- Add a `stock-items-mock.service` to services\n\n```typescript path=src/services/stock-items-mock.service.ts\nimport {StockItemsApi} from './stock-items.api';\nimport {StockItemModel} from '../models';\n\n\nexport class StockItemsMockService implements StockItemsApi {\n  async listStockItems(): Promise<StockItemModel[]> {\n    return [\n      {\n        id: \"1\",\n        name: \"Self-sealing stem bolt\",\n        description: \"Self-sealing stem bolt\",\n        stock: 10,\n        unitPrice: 10.5,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Bajor Galactic\"\n      },\n      {\n        id: \"2\",\n        name: \"Heisenberg compensator\",\n        description: \"Magical component that negates the effects of the Heisenberg Uncertainty Principle\",\n        stock: 20,\n        unitPrice: 20.0,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Federation Imports\"\n      },\n      {\n        id: \"3\",\n        name: \"Tooth sharpener\",\n        description: \"Industrial strength tooth sharpener\",\n        stock: 30,\n        unitPrice: 5.25,\n        picture: \"https://via.placeholder.com/32.png\",\n        manufacturer: \"Farenginar Exploits\"\n      }\n    ];\n  }\n}\n```\n\n- Add the mock service to the `index.ts` file in the services directory\n\n```typescript path=src/services/index.ts\n...\nexport * from './stock-items-mock.service';\n...\n```\n\n- Start the service\n\n```bash\nnpm start\n```\n<Tabs>\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwopenapp.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n<Tab label=\"Desktop/Laptop\">\n- Open a browser to `http://localhost:3000/api-docs` and execute the stock items controller. You should see the data from\nabove returned by the service.\n</Tab>\n</Tabs>\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds a mock service implementation\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n#### Add a GraphQL implementation of Stock Items\n\nThe GraphQL <Globals name=\"template\" /> supports both REST and GraphQL APIs for accessing backend services. We created\na REST controller to expose the results from the service and now we will do the same\nfor GraphQL.\n\n- Create a `stock-items` GraphQL schema in the `schemas` directory\n\n```typescript path=src/schemas/stock-item.schema.ts\nimport {Field, Float, Int, ObjectType} from 'type-graphql';\nimport {StockItemModel} from '../models';\n\n@ObjectType()\nexport class StockItem implements StockItemModel {\n  @Field()\n  id: string;\n  @Field()\n  description: string;\n  @Field()\n  manufacturer: string;\n  @Field()\n  name: string;\n  @Field({nullable: true})\n  picture: string;\n  @Field(type => Int)\n  stock: number;\n  @Field(type => Float)\n  unitPrice: number;\n}\n```\n\n- Add the stock-items schema to the `index.ts` in the schemas directory\n\n```typescript path=src/schemas/index.ts\nexport * from './stock-item.schema'\n```\n\n- Add a 'stock-item' GraphQL resolver in the `resolvers` directory\n\n```typescript path=src/resolvers/stock-item.resolver.ts\nimport {Query, Resolver} from 'type-graphql';\nimport {Inject} from 'typescript-ioc';\n\nimport {resolverManager} from './_resolver-manager';\nimport {StockItem} from '../schemas';\nimport {StockItemModel} from '../models';\nimport {StockItemsMockService} from '../services';\n\n@Resolver(of => StockItem)\nexport class StockItemResolver {\n  @Inject\n  service: StockItemsMockService;\n\n  @Query(returns => [StockItem])\n  async stockItems(): Promise<StockItemModel[]> {\n    return this.service.listStockItems();\n  }\n}\n\nresolverManager.registerResolver(StockItemResolver);\n```\n\n<InlineNotification>\n\n**Note:** The <Globals name=\"template\" /> includes a `resolverManager` component that simplifies the steps to\nmake the resolver available. All that is required to use the resolver is to register it, preferably\nat the bottom of the module where it is defined.\n\n</InlineNotification>\n\n- Add the stock-items resolver to `index.ts` in the resolvers directory\n\n```typescript path=src/resolvers/index.ts\nexport * from './stock-item.resolver';\n```\n\n- Start the service\n\n```bash\nnpm start\n```\n- Verify that the that the resolver is available using the Graph QL browser provided by the <Globals name=\"template\" />\n    - Open GraphQL Playground: `http://localhost:3000`\n    - Run the query `query { stockItems { name } }`\n    \n<Tabs>\n<Tab label=\"Cloud Shell\">\n\n - To view the running app click on the **Eye Icon** on the top right and select the port `3000` this will open a browser tab and display the running app on that port.\n\n    ![View App](./images/viewapp.png)\n\n</Tab>\n\n<Tab label=\"Gitpod\">\n\n - Once you run the application,gitpod gives the option to make the port \"Public\".Once you make the port Public, it gives you the option to \"Open Preview\" or \"Open Browser\".\n\n    ![View App](./images/gitpod01.png)\n\n- Selecting \"Open Preview\" opens a window inside gitpod workspace tab.\n\n    ![OpenPreview](./images/gitpod02.png)\n\n- Selecting \"Open Browser\" opens a new browser tab for accessing the URL.\n\n</Tab>\n\n<Tab label=\"Code Ready Workspaces\">\n\n![CRW Open Link](./images/crwopenlink.png)\n\n\n- Click on open link \n\n\n![CRW Open App](./images/crwgraphql.png)\n\n\n- To view this application in new tab click top right corner arrow icon\n\n</Tab>\n<Tab label=\"Desktop/Laptop\">\n- Open GraphQL Playground: `http://localhost:3000`\n\n</Tab>\n\n\n\n\n</Tabs>\n\n\n\n- Push the changes we've made to the repository\n\n```bash\ngit add .\ngit commit -m \"Adds a graphql interface\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n#### Create a service implementation that calls the microservice\n\n- Create a folder `config` in following path `src/config`\n\n- Add a `stock-item-service.config` file in the config directory\n\n```typescript path=src/config/stock-item-service.config.ts\nexport class StockItemServiceConfig {\n  baseUrl: string;\n}\n```\n- Add a `stock-item-service.config.provider` file in the config directory\n\n```typescript path=src/config/stock-item-service.config.provider.ts\nimport {ObjectFactory} from 'typescript-ioc';\n\nconst baseUrl: string = process.env.SERVICE_URL || 'localhost:9080';\n\nexport const stockItemConfigFactory: ObjectFactory = () => ({\n  baseUrl,\n});\n```\n\nThe config class separates how the config is loaded from how it is used. In this case the config is simply\nretrieved from an environment variable but in more complex cases the value(s) can be retrived from external\ndata sources.\n\n- Add the `stock-item-service.config` to an index.ts of the config directory\n\n```typescript path=src/config/index.ts\nimport {StockItemServiceConfig} from './stock-item-service.config';\nimport {stockItemConfigFactory} from './stock-item-service.config.provider';\nimport {Container} from 'typescript-ioc';\n\nexport * from './stock-item-service.config';\n\nContainer.bind(StockItemServiceConfig).factory(stockItemConfigFactory);\n```\n\n- Create a `stock-items` service in the services directory that uses the config\n\n```typescript path=src/services/stock-items.service.ts\nimport {Inject} from 'typescript-ioc';\nimport {get, Response} from 'superagent';\n\nimport {StockItemsApi} from './stock-items.api';\nimport {StockItemModel} from '../models';\nimport {StockItemServiceConfig} from '../config';\nimport {LoggerApi} from '../logger';\n\nclass StockItem {\n  'id'?: string;\n  'manufacturer'?: string;\n  'name'?: string;\n  'price'?: number;\n  'stock'?: number;\n}\n\nexport class StockItemsService implements StockItemsApi {\n  @Inject\n  _logger: LoggerApi;\n  @Inject\n  config: StockItemServiceConfig;\n\n  get logger(): LoggerApi {\n    return this._logger.child('StockItemsService');\n  }\n\n  async listStockItems(): Promise<StockItemModel[]> {\n    try {\n      const response: Response = await get(this.config.baseUrl + '/stock-items')\n        .set('Accept', 'application/json');\n\n      return this.mapStockItems(response.body);\n    } catch (err) {\n      this.logger.error('Error getting data from service', err);\n      throw err;\n    }\n  }\n\n  mapStockItems(data: StockItem[]): StockItemModel[] {\n    return data.map(this.mapStockItem);\n  }\n\n  mapStockItem(item: StockItem): StockItemModel {\n    return {\n      id: item.id,\n      name: item.name,\n      description: item.name,\n      stock: item.stock,\n      unitPrice: item.price,\n      picture: 'https://via.placeholder.com/32.png',\n      manufacturer: item.manufacturer,\n    };\n  }\n}\n```\n\n- Add `stock-item.service` to `index.ts` in the service directory\n- Add `StockItemsService` instead of `StockItemsMockService` in the following files `src/resolvers/stock-item.resolver.ts` ,\n  `src/controllers/stock-items.controller.ts` and `test/controllers/stock-items.controller.spec.ts`\n\n\n- Remove `stock-items-mock.service` from `index.ts`\n\n```typescript path=src/services/index.ts\nexport * from './stock-items.service';\n```\n\n\n- Modify `connectsTo` property to the values.yaml file of the Helm chart. The value of the property should match the\nKubernetes service of the microservice. (For <Globals name=\"template\" /> projects, the service name is the same as the name of the\napplication which is that same as the name of the repository.)\n\n```yaml path=chart/base/values.yaml\n...\n\nconnectsTo: inventory-management-svc-{your initials}\n\n...\n```\n\nThe `values.yaml` file of the Helm chart defines the variables that can be provided to the\ntemplate as input. Now that we've added a new variable, we will need to update the appropriate\ntemplate file to use our new variable.\n\n- Add a new environment variable named `SERVICE_URL` to the list of existing environment variables in deployment.yaml.\n(`SERVICE_URL` is the name we gave the environment variable in our `stock-item-service.config` class as the first step in\nthis section.) The value of this environment variable should come from the `connectsTo` value we defined. You can add\n`| quote` to wrap the value in quotes in case the value is not formatted correctly.\n\n```yaml path=chart/base/templates/deployment.yaml\n  ...\n  env:\n    - name: INGRESS_HOST\n      value: \"\"\n    - name: PROTOCOLS\n      value: \"\"\n    - name: LOG_LEVEL\n      value: {{ .Values.logLevel | quote }}\n    - name: SERVICE_URL\n      value: {{ printf \"%s:80\" .Values.connectsTo | quote }}\n  ...\n```\n\n`deployment.yaml` is a templatized Kubernetes yaml file that describes the deployment of our component.\nThe deployment will create one or more pods based on the pod template defined in the deployment.\nEach pod that starts will have the envionment variables that we have defined in the `env` section\navailable for the container image to reference.\n\n- Commit and push the changes to git\n\n```bash\ngit add .\ngit commit -m \"Adds service implementation\"\ngit push\n```\n\n- Open the [pipeline to see it running](/developer-intermediate/deploy-app#view-your-application-pipeline)\n\n","fileAbsolutePath":"/workspace/ibm-gsi-cloudnative-journey/src/pages/developer-intermediate/inventory-bff/index.mdx"}}},"staticQueryHashes":["1054721580","1054721580","1364590287","2102389209","2102389209","2456312558","2746626797","2746626797","3018647132","3018647132","3037994772","3037994772","3273249464","768070550"]}